import asyncio
from pyrogram import Client
from pyrogram.enums import MessageEntityType

# --- Configuration variables ---
# Channel monitoring settings
CHANNEL_USERNAME = "solearlytrending" # Set this to your target channel
PREFIX_TO_REMOVE = "https://t.me/soul_sniper_bot?start=15_" # The specific prefix to remove from URLs

# Target user for sending all extracted content (URLs from channel, strings from group)
TARGET_USER = '@hector_trojanbot' # The user to whom processed content will be sent

# Group monitoring settings
GROUP_CHAT_ID = -1002348692189 # !!! IMPORTANT: The specific ID of the Telegram group to monitor
MONITORED_USER_IDS = [7707642578, 7009201216] # !!! IMPORTANT: The IDs of the persons to monitor in the group

# Keywords for string extraction from group messages
STRING_KEYWORDS = ['bonk', 'pump', 'moon', 'jups']
MIN_STRING_LENGTH = 43

async def get_last_messages():
    """
    Connects to Telegram, retrieves the last 3 messages from the specified channel,
    extracts and processes specific URLs, and sends unique processed URLs to a target user.
    Additionally, it actively monitors messages from specified users in a particular group,
    extracting and sending specific strings based on length and keywords.
    This process runs continuously with a short delay between checks.
    """
    # Initialize sets to store already sent items to prevent duplicates
    sent_channel_urls = set() # For URLs extracted from the channel
    sent_group_strings = set() # For special strings extracted from the group

    # Initialize the Pyrogram Client.
    # "my_account" is the session name. If it doesn't exist, Pyrogram will ask
    # you to log in the first time you run the script.
    async with Client("my_account") as app:
        # Outer loop to repeat the process indefinitely
        # The loop runs for a very large number of iterations, effectively infinite.
        for iteration in range(999999999):
            print(f"\n--- Starting message processing iteration {iteration + 1} ---")
            try:
                # --- CHANNEL MONITORING ---
                print(f"\n--- Checking channel: {CHANNEL_USERNAME} for URLs ---")
                # Retrieve the last 3 messages from the channel
                async for message in app.get_chat_history(CHANNEL_USERNAME, limit=3):
                    await process_channel_message_for_url(message, sent_channel_urls, app, iteration)

                # --- GROUP MONITORING ---
                print(f"\n--- Checking group: {GROUP_CHAT_ID} for messages from {MONITORED_USER_IDS} ---")
                # Fetch last 10 messages from the group to check for new messages from specific users.
                # The limit is increased to 10 to have a better chance of catching recent messages.
                async for message in app.get_chat_history(GROUP_CHAT_ID, limit=10):
                    # Check if the message has a sender and if that sender's ID is in our list of monitored users
                    if message.from_user and message.from_user.id in MONITORED_USER_IDS:
                        print(f"--- Found message from monitored user: @{message.from_user.username or message.from_user.id} in group {GROUP_CHAT_ID} ---")
                        await process_group_message_for_string(message, sent_group_strings, app, iteration)
                    else:
                        # Silently skip messages from non-monitored users or messages without a sender
                        pass

            except Exception as e:
                # Catch and print any errors that occur during message retrieval or processing
                print(f"An error occurred during iteration {iteration + 1}: {e}")

            # Wait for a short period before the next iteration to enable active monitoring
            print(f"\n--- Iteration {iteration + 1} complete. Waiting 5 seconds before next check... ---")
            await asyncio.sleep(5) # Reduced sleep time for more active monitoring


async def process_channel_message_for_url(message, sent_channel_urls, app, iteration):
    """
    Helper function to process a single message from the channel, extract URLs,
    remove prefix, check for duplicates, and send to target user.
    """
    message_content = None
    message_type_display = "[UNKNOWN CONTENT TYPE]"
    processed_url = None
    entities_to_check = None

    if message.caption:
        message_content = message.caption
        message_type_display = "message.caption"
        entities_to_check = message.caption_entities
    elif message.text:
        message_content = message.text
        message_type_display = "message.text"
        entities_to_check = message.entities
    elif message.photo:
        message_type_display = "message.photo"
        message_content = f"[Photo] File ID: {message.photo.file_id}"
        entities_to_check = message.caption_entities
    elif message.video:
        message_type_display = "message.video"
        message_content = f"[Video] File ID: {message.video.file_id}"
        entities_to_check = message.caption_entities
    elif message.document:
        message_type_display = "message.document"
        message_content = f"[Document] File Name: {message.document.file_name or 'N/A'}"
        entities_to_check = message.caption_entities
    elif message.poll:
        message_type_display = "message.poll"
        message_content = f"[Poll] Question: {message.poll.question} (ID: {message.poll.id})"
        entities_to_check = None
    elif message.web_page:
        message_type_display = "message.web_page"
        message_content = f"[Web Page Preview] Title: {message.web_page.title or 'N/A'} URL: {message.web_page.url or 'N/A'}"
        if message.web_page.url and PREFIX_TO_REMOVE in message.web_page.url:
            processed_url = message.web_page.url.replace(PREFIX_TO_REMOVE, "")
        entities_to_check = None
    else:
        message_content = f"[{message_type_display} - No extractable text/caption]"
        entities_to_check = None

    if not processed_url and entities_to_check:
        for entity in entities_to_check:
            if entity.type == MessageEntityType.TEXT_LINK and entity.url and PREFIX_TO_REMOVE in entity.url:
                processed_url = entity.url.replace(PREFIX_TO_REMOVE, "")
                break
            elif entity.type == MessageEntityType.URL and message_content:
                url_in_text = message_content[entity.offset : entity.offset + entity.length]
                if PREFIX_TO_REMOVE in url_in_text:
                    processed_url = url_in_text.replace(PREFIX_TO_REMOVE, "")
                    break

    print(f"\n--- Channel Message Details (Iteration {iteration + 1}) ---")
    print(f"Message Type Used: {message_type_display}")
    print(f"Message Content:\n{message_content}")

    if processed_url:
        print(f"--- Processed Channel URL Part: {processed_url} ---")
        if processed_url not in sent_channel_urls:
            message_to_send = f"New CA (Channel): \n- {processed_url}\n"
            try:
                await app.send_message(
                    chat_id=TARGET_USER,
                    text=message_to_send
                )
                print(f"Successfully sent NEW processed channel URL part to {TARGET_USER}")
                sent_channel_urls.add(processed_url)
            except Exception as e:
                print(f"Failed to send processed channel URL part to {TARGET_USER}: {e}")
        else:
            print(f"--- Skipping duplicate Channel URL: {processed_url} (already sent) ---")
    else:
        print("--- No matching URLs Extracted or Processed for this channel message ---")
    print("-----------------------------------------------------------------")


async def process_group_message_for_string(message, sent_group_strings, app, iteration):
    """
    Helper function to process a single message from the group, extract specific strings,
    check for duplicates, and send to target user.
    """
    content_to_check = message.text or message.caption

    print(f"\n--- Group Message Details (Iteration {iteration + 1}) ---")
    print(f"From User: @{message.from_user.username or message.from_user.id}")
    print(f"Message Content:\n{content_to_check}")

    extracted_string = await extract_special_string(content_to_check)

    if extracted_string:
        print(f"--- Extracted Group String: {extracted_string} ---")
        if extracted_string not in sent_group_strings:
            message_to_send = f"New CA (Group from @{message.from_user.username or message.from_user.id}): \n- {extracted_string}\n"
            try:
                await app.send_message(
                    chat_id=TARGET_USER,
                    text=message_to_send
                )
                print(f"Successfully sent NEW extracted group string to {TARGET_USER}")
                sent_group_strings.add(extracted_string)
            except Exception as e:
                print(f"Failed to send extracted group string to {TARGET_USER}: {e}")
        else:
            print(f"--- Skipping duplicate Group String: {extracted_string} (already sent) ---")
    else:
        print("--- No matching string found in this group message ---")
    print("-----------------------------------------------------------------")


async def extract_special_string(text_content):
    """
    Extracts a string from the given text content if it meets the criteria:
    - At least MIN_STRING_LENGTH characters long.
    - Contains any of the STRING_KEYWORDS.
    Assumes the string is a contiguous "word" or token.
    """
    if not text_content:
        return None

    # Split the content into words/tokens. A simple split works for contiguous strings.
    words = text_content.split()

    for word in words:
        # Clean the word from common leading/trailing punctuation to ensure accurate length and keyword checks
        # This helps if the string is like "stringpump."
        cleaned_word = word.strip('.,!?"\'`~')

        if len(cleaned_word) >= MIN_STRING_LENGTH:
            for keyword in STRING_KEYWORDS:
                # Check for keyword presence (case-sensitive as not specified otherwise)
                if keyword in cleaned_word:
                    return cleaned_word # Return the first matching string found

    return None

# Run the main asynchronous function
asyncio.run(get_last_messages())
